# HTTP заголовки и их поиск/сравнение

## Что такое?

1. [RFC 2616 Hypertext Transfer Protocol -- HTTP/1.1](https://www.rfc-editor.org/rfc/rfc2616.html#page-31)
2. [RFC 822 STANDARD FOR THE FORMAT ARPA INTERNET TEXT MESSAGES](https://www.rfc-editor.org/rfc/rfc822#section-3.1)

[MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers) описывает как

> HTTP headers let the client and the server pass additional information with an HTTP request or response. An HTTP header consists of its case-insensitive name followed by a colon (:), then by its value. Whitespace before the value is ignored.

## Особенности

Выглядит всё как обычная строковая пара *"ключ-значение"*, но нет.
Внимание на **case-insensitive** в описании, в этой паре *ключ* должен интерпретироваться всеми участниками информационного обмена как **регистронезависимая** строка. Т.е. пары

```
Content-Encoding: gzip
CONTENT-encoding: gzip
content-encoding: gzip
```

эквивалентны.

Таким образом, набор заголовков в общем случае не стоит воспринимать как обычный _словарь (dictionary, map, hashmap)_ со строковыми ключами.

## Go stdlib

Пакет `http` работает с именами заголовков как с регистронезависимыми строками преобразуя их к одной конвенции `http.CanonicalHeaderKey(key string)`. Весь API для типа `http.Header` обложен предупреждениями об использовании каноничной формы. Каноничная форма `Capitalize-First-Letter-After-Dash`.

Таким образом гошный API в принципе *позволяет* использовать неканоничную форму заголовка, просто для работы с ними не надо смешивать API, напр.

```go
key := "X-WWW-SomeKey"
header.Add(key, "value")
value := header[key]
```

Значение тут получить не удастся, т.к. при вызове `Add` имя заголовка будет приведено к каноничной форме.

## А в чем проблема у нас

Есть в `common` API для передачи через заголовки произвольных пар *"ключ-значение"*. Это всё работает для HTTP, gRPC, AMQP и умеет упаковываться/распаковываться в контекст `context.Context` с помощью набора *middleware*. Так вот, не всегда то, что упаковано на одной стороне с помощью нашего *middleware* будет распаковано на другой.

**Почему?** Потому же, почему не работает пример выше. В качестве префикса таких заголовков используется `X-KV-`, как видим он неканоничный, а поиск реализован регистрозависимый как по обычному словарю.

## Как чинить

Пока оставил и старый поиск и новый добавил, по каноничной форме. Наверно его надо вообще переписать на полное приведение к каноничной форме и всех имен заголовков и эталона для поиска. Но побоялся отломать что-то, завязанное на предыдущее поведение.

## Как избегать

1. Использовать только специализированный API для `http.Headers`
2. Очень аккуратно и с пониманием работать с `http.Headers` как с коллекцией/словарем.

